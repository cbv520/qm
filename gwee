package mux41;

import lombok.AllArgsConstructor;
import lombok.Data;
import org.apache.jena.graph.Node;
import org.apache.jena.query.Query;
import org.apache.jena.query.QueryFactory;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.rdf.model.ModelFactory;
import org.apache.jena.rdf.model.ResourceFactory;
import org.apache.jena.sparql.core.DatasetGraphFactory;
import org.apache.jena.sparql.core.PathBlock;
import org.apache.jena.sparql.core.TriplePath;
import org.apache.jena.sparql.core.Var;
import org.apache.jena.sparql.engine.ExecutionContext;
import org.apache.jena.sparql.engine.binding.Binding;
import org.apache.jena.sparql.engine.binding.BindingBuilder;
import org.apache.jena.sparql.engine.binding.BindingRoot;
import org.apache.jena.sparql.path.PathLib;
import org.apache.jena.sparql.syntax.Element;
import org.apache.jena.sparql.syntax.ElementGroup;
import org.apache.jena.sparql.syntax.ElementOptional;
import org.apache.jena.sparql.syntax.ElementPathBlock;
import org.apache.jena.vocabulary.RDF;

import java.io.ByteArrayInputStream;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Test2 {


    public static CoverageResult getBestCoverage(List<TriplePath> tps, Map<Var, List<Node>> bindings, ExecutionContext ctx) {
        var bindingIter = new BindingIter(bindings);
        double bestCoverage = -1;
        Binding bestBinding = null;
        while (bindingIter.hasNext()) {
            var binding = bindingIter.next();
            var cvg = coverage(tps, binding, ctx);
            if (cvg == 1.0) {
                return new CoverageResult(binding, 1.0);
            }
            if (cvg > bestCoverage) {
                bestCoverage = cvg;
                bestBinding = binding;
            }
        }
        return new CoverageResult(bestBinding, bestCoverage);
    }

    public static double coverage(List<TriplePath> tps, Binding b, ExecutionContext ctx) {
        int matches = 0;
        for (var tp : tps) {
            if (PathLib.execTriplePath(b, tp, ctx).hasNext()) {
                matches++;
            }
        }
        return (double) matches / tps.size();
    }

    public static Map<Var, Set<String>> getAcceptedRdfClasses(Query query) {
        Map<Var, Set<String>> accepted = new HashMap<>();
        getQueryTriplePaths(query).forEach(tp -> {
            if (tp.getSubject().isVariable() && tp.getPredicate() != null && tp.getPredicate().equals(RDF.type.asNode()) && tp.getObject().isURI()) {
                var var = Var.alloc(tp.getSubject());
                accepted.putIfAbsent(var, new HashSet<>());
                accepted.get(var).add(tp.getObject().getURI());
            }
        });
        return accepted;
    }

    public static Map<String, String> getRdfClasses(Model data) {
        Map<String, String> accepted = new HashMap<>();
        data.getGraph().find(Node.ANY, RDF.type.asNode(), Node.ANY)
                .filterKeep(t -> t.getSubject().isURI() && t.getObject().isURI())
                .forEach(t -> accepted.put(t.getSubject().getURI(), t.getObject().getURI()));
        return accepted;
    }

    public static Map<Var, List<Node>> optimise(Map<Var, Set<Node>> bindings, Map<Var, Set<String>> accepted, Map<String, String> outputTypes) {
        Map<Var, List<Node>> optimised = bindings.entrySet().stream()
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        e -> new ArrayList<>(e.getValue())));
        optimised.forEach((var, nodeList) -> {
            nodeList.sort(Comparator.comparing((Node node) ->
                    rdfClassCompare(var, node, accepted, outputTypes)).reversed());
        });
        return optimised;
    }

    private static int rdfClassCompare(Var var, Node node, Map<Var, Set<String>> accepted, Map<String, String> nodeTypes) {
        if (!node.isURI()) {
            return 0;
        }
        var nodeType = nodeTypes.get(node.getURI());
        if (nodeType == null) {
            return 0;
        } else {
            var acceptsTypes = accepted.get(var);
            if (acceptsTypes == null) {
                return 0;
            }
            if (acceptsTypes.contains(nodeType)) {
                return 1;
            } else {
                return -1;
            }
        }
    }

    public static ExecutionContext createExecutionContext(Model m) {
        return new ExecutionContext(DatasetGraphFactory.create(m.getGraph()));
    }

    public static Map<Var, Set<Node>> getPossibleBindings(List<TriplePath> tps, ExecutionContext ctx) {
        Map<Var, Set<Node>> bindings = new HashMap<>();
        for (var tp : tps) {
            var qIter = PathLib.execTriplePath(BindingRoot.create(), tp, ctx);
            while (qIter.hasNext()) {
                var binding = qIter.next();
                binding.forEach((var, node) -> {
                    bindings.compute(var, (k,v) -> {
                        if (v == null) {
                            v = new HashSet<>();
                        }
                        v.add(node);
                        return v;
                    });
                });
            }
        }
        return bindings;
    }

    public static List<TriplePath> getQueryTriplePaths(Query query) {
        return streamQueryPathBlocks(query)
                .flatMap(pb -> pb.getList().stream())
                .collect(Collectors.toList());
    }

    public static Stream<PathBlock> streamQueryPathBlocks(Query query) {
        return streamQueryPathBlocks(query.getQueryPattern());
    }

    public static Stream<PathBlock> streamQueryPathBlocks(Element el) {
        if (el instanceof ElementPathBlock) {
            return Stream.of(((ElementPathBlock) el).getPattern());
        }
        if (el instanceof ElementGroup) {
            return ((ElementGroup) el).getElements().stream()
                    .flatMap(Test2::streamQueryPathBlocks);
        }
        if (el instanceof ElementOptional) {
            return streamQueryPathBlocks(((ElementOptional) el).getOptionalElement());
        }
        return Stream.empty();
    }

    public static class BindingIter implements Iterator<Binding> {

        private final CartesianProduct cpIter;
        private final List<Var> vars;
        private final List<List<Node>> nodes;
        private final List<Binding> buffer;
        private final Random random = new Random(123);
        private Iterator<Binding> bufferIter;

        public BindingIter(Map<Var, List<Node>> bb) {
            this.vars = new ArrayList<>(bb.keySet());
            this.nodes = bb.values().stream().map(ArrayList::new).collect(Collectors.toList());
            this.buffer = new ArrayList<>();
            int[] lengths = new int[this.vars.size()];
            for (int i = 0; i < this.vars.size(); i++) {
                lengths[i] = nodes.get(i).size();
            }
            this.cpIter = new CartesianProduct(lengths);
            bufferAndShuffle();
        }

        private void bufferAndShuffle() {
            buffer.clear();
            int n = 0;
            while (cpIter.hasNext() && n < 1000) {
                var bindingBuilder = BindingBuilder.create();
                var next = cpIter.next();
                for (int i = 0; i < next.length; i++) {
                    bindingBuilder.add(vars.get(i), nodes.get(i).get(next[i]));
                }
                buffer.add(bindingBuilder.build());
                n++;
            }
            Collections.shuffle(buffer, random);
            bufferIter = buffer.iterator();
        }

        @Override
        public boolean hasNext() {
            if (!cpIter.hasNext() && !bufferIter.hasNext()) {
                return false;
            }
            if (!bufferIter.hasNext()) {
                bufferAndShuffle();
            }
            return bufferIter.hasNext();
        }

        @Override
        public Binding next() {
            return bufferIter.next();
        }
    }

    public static class CartesianProduct implements Iterable<int[]>, Iterator<int[]> {
        private final int[] _lengths;
        private final int[] _indices;
        private boolean _hasNext = true;

        public CartesianProduct(int[] lengths) {
            _lengths = lengths;
            _indices = new int[lengths.length];
        }

        public boolean hasNext() {
            return _hasNext;
        }

        public int[] next() {
            int[] result = Arrays.copyOf(_indices, _indices.length);
            for (int i = _indices.length - 1; i >= 0; i--) {
                if (_indices[i] == _lengths[i] - 1) {
                    _indices[i] = 0;
                    if (i == 0) {
                        _hasNext = false;
                    }
                } else {
                    _indices[i]++;
                    break;
                }
            }
            return result;
        }

        public Iterator<int[]> iterator() {
            return this;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    @Data
    @AllArgsConstructor
    public static class CoverageResult {
        Binding binding;
        double coverage;
    }

    public static Model model(String str) {
        var model = ModelFactory.createDefaultModel();
        model.read(new ByteArrayInputStream(str.getBytes()), null, "TTL");
        return model;
    }
}
